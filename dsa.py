# -*- coding: utf-8 -*-
"""Interview_questions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HMOIKZEoM3-87qUdTa2EkkiPDk3UcgId
"""

# DFS
graph = {'A':['B','C','D'],
         'B':['A','E','D'],
         'C':['A','D'],
         'D':['A','B','C','E'],
         'E':['B','D']}



def DFS(node,visited,graph):
  if node not in graph:
    print('node is not present')
    return

  if node not in visited:
    print(node)
    visited.add(node)
    for i in graph[node]:
      DFS(i,visited,graph)

node = 'A'
visited = set()
DFS(node,visited,graph)

#BFS
from collections import deque

def bfs(graph,start_node):
  visited = set()
  queue = deque()

  queue.append(start_node)
  visited.add(start_node)

  while queue:
    node = queue.popleft()
    print(node, end=' ')

    for neighbor in graph[node]:
      if neighbor not in visited:
        queue.append(neighbor)
        visited.add(neighbor)

graph = {'A':['B','C'],
         'B':['A','D','E'],
         'C':['A','F'],
         'D':['B'],
         'E':['B','F'],
         'F':['C','E']}

bfs(graph,'A')

# Linked List

class Node:
  def __init__(self,data):
    self.data=data
    self.next=None

class LinkedList:
  def __init__(self):
    self.head=None

  def append(self,data):
    new_node = Node(data)

    if self.head is None:
      self.head=new_node
      return

    curr_node = self.head
    while curr_node.next is not None:
      curr_node=curr_node.next
    curr_node.next=new_node

  def print_data(self):
    curr_node = self.head
    while curr_node is not None:
      print(curr_node.data)
      curr_node=curr_node.next

  def delete_node(self,value):
    if self.head is None:
      return

    if self.head.data==value:
      self.head = self.head.next
      return

    curr_node = self.head
    while curr_node.next is not None:
      if curr_node.next.data==value:
        curr_node.next=curr_node.next.next
        return
      curr_node=curr_node.next


l = LinkedList()
l.append(5)
l.append(30)
l.append(15)
l.print_data()

l.delete_node(30)
print('------------')
l.print_data()

# Binary Tree
class TreeNode:
  def __init__(self,val):
    self.val = val
    self.left=None
    self.right=None

class BinaryTree:
  def __init__(self):
    self.root=None

  def insert(self,val):
    if self.root is None:
      self.root=TreeNode(val)
    else:
      current=self.root
      while True:
        if val<current.val:
          if not current.left:
            current.left=TreeNode(val)
            break
          else:
            current=current.left
        else:
          if not current.right:
            current.right=TreeNode(val)
            break
          else:
            current=current.right

  def search(self,val):
    current = self.root
    while current:
      if val==current.val:
        return True
      elif val<current.val:
        current=current.left
      else:
        current=current.right
    return False

tree = BinaryTree()
tree.insert(5)
tree.insert(3)
tree.insert(7)

print(tree.search(75))

# Binary Search
def binary_search(arr,x):
  low = 0
  high = len(arr)-1
  mid = 0

  while low<=high:
    mid = (high+low)//2
    if arr[mid]<x:
      low=mid+1
    elif arr[mid]>x:
      high=mid-1
    else:
      return mid
  return -1

arr = [ 2, 3, 4, 10, 40,67,10,92 ]
x = 67
print(binary_search(arr,x))

# Linear Search

lst = [64, 25, 12, 22, 11]
for i in range(len(lst)):
  for j in range(len(lst)-1):
    if lst[j]>lst[j+1]:
      lst[j],lst[j+1]=lst[j+1],lst[j]

print(lst)

# Selection Sort
def selection_sort(lst):
  for i in range(len(lst)):
    min_val_index = i
    for j in range(i+1,len(lst)):
      if lst[j]<lst[min_val_index]:
        min_val_index=j
    lst[i],lst[min_val_index]=lst[min_val_index],lst[i]
  return lst

lst = [54,23,99,6,1,67,8]
selection_sort(lst)

# Insertion Sort
def insertion_sort(lst):
  for i in range(1,len(lst)):
    curr=lst[i]
    j=i-1
    while j>=0 and lst[j]>curr:
      lst[j+1]=lst[j]
      j-=1
    lst[j+1]=curr
  return lst

lst = [54,23,99,6,1,67,8]
insertion_sort(lst)

# Quick Sort
def quicksort(lst):
  if len(lst)<2:
    return lst

  pivot = lst[-1]
  smaller = []
  larger=[]

  for i in lst[:-1]:
    if i<pivot:
      smaller.append(i)
    else:
      larger.append(i)
  return quicksort(smaller)+[pivot]+quicksort(larger)

lst = [54,23,99,6,1,67,8]
quicksort(lst)

# Merge Sort

def merge_sort(lst):
  if len(lst)<=1:
    return lst

  mid = len(lst)//2
  left_half=lst[:mid]
  right_half=lst[mid:]

  left_half = merge_sort(left_half)
  right_half=merge_sort(right_half)

  return merge(left_half,right_half)

lst = [54,23,99,6,1,67,8]
merge_sort(lst)

def merge(left_half,right_half):
  merged=[]
  left_index=0
  right_index=0

  while left_index<len(left_half) and right_index<len(right_half):
    if left_half[left_index]<right_half[right_index]:
      merged.append(left_half[left_index])
      left_index+=1
    else:
      merged.append(right_half[right_index])
      right_index+=1

  while left_index<len(left_half):
    merged.append(left_half[left_index])
    left_index+=1

  while right_index<len(right_half):
    merged.append(right_half[right_index])
    right_index+=1
  return merged

# Stack
class Stack:
  def __init__(self):
    self.stack=[]

  def push(self,item):
    self.stack.append(item)

  def pop(self):
    if len(self.stack)==0:
      return None
    return self.stack.pop()

  def peek(self):
    if len(self.stack)==0:
      return None
    return self.stack[-1]

my_stack=Stack()
my_stack.push(5)
my_stack.push(10)
my_stack.push(15)

print(my_stack.peek())
my_stack.pop()
print('After pop:',my_stack.peek())

# Queue
class Queue:
  def __init__(self):
    self.items=[]

  def enqueue(self,item):
    self.items.append(item)

  def dequeue(self):
    if len(self.items)==0:
      print('list is empty')
      return
    self.items.pop(0)

  def peek(self):
    if len(self.items)==0:
      print('list is empty')
      return
    return self.items[0]

q = Queue()
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)

print('peek:',q.peek())
q.dequeue()
print('after depeek:',q.peek())
