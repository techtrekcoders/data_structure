# -*- coding: utf-8 -*-
"""Interview_questions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HMOIKZEoM3-87qUdTa2EkkiPDk3UcgId
"""

# DFS
graph = {'A':['B','C','D'],
         'B':['A','E','D'],
         'C':['A','D'],
         'D':['A','B','C','E'],
         'E':['B','D']}



def DFS(node,visited,graph):
  if node not in graph:
    print('node is not present')
    return

  if node not in visited:
    print(node)
    visited.add(node)
    for i in graph[node]:
      DFS(i,visited,graph)

node = 'A'
visited = set()
DFS(node,visited,graph)

#BFS
from collections import deque

def bfs(graph,start_node):
  visited = set()
  queue = deque()

  queue.append(start_node)
  visited.add(start_node)

  while queue:
    node = queue.popleft()
    print(node, end=' ')

    for neighbor in graph[node]:
      if neighbor not in visited:
        queue.append(neighbor)
        visited.add(neighbor)

graph = {'A':['B','C'],
         'B':['A','D','E'],
         'C':['A','F'],
         'D':['B'],
         'E':['B','F'],
         'F':['C','E']}

bfs(graph,'A')

# Linked List

class Node:
  def __init__(self,data):
    self.data=data
    self.next=None

class LinkedList:
  def __init__(self):
    self.head=None

  def append(self,data):
    new_node = Node(data)

    if self.head is None:
      self.head=new_node
      return

    curr_node = self.head
    while curr_node.next is not None:
      curr_node=curr_node.next
    curr_node.next=new_node

  def print_data(self):
    curr_node = self.head
    while curr_node is not None:
      print(curr_node.data)
      curr_node=curr_node.next

  def delete_node(self,value):
    if self.head is None:
      return

    if self.head.data==value:
      self.head = self.head.next
      return

    curr_node = self.head
    while curr_node.next is not None:
      if curr_node.next.data==value:
        curr_node.next=curr_node.next.next
        return
      curr_node=curr_node.next


l = LinkedList()
l.append(5)
l.append(30)
l.append(15)
l.print_data()

l.delete_node(30)
print('------------')
l.print_data()

# Binary Tree
class TreeNode:
  def __init__(self,val):
    self.val = val
    self.left=None
    self.right=None

class BinaryTree:
  def __init__(self):
    self.root=None

  def insert(self,val):
    if self.root is None:
      self.root=TreeNode(val)
    else:
      current=self.root
      while True:
        if val<current.val:
          if not current.left:
            current.left=TreeNode(val)
            break
          else:
            current=current.left
        else:
          if not current.right:
            current.right=TreeNode(val)
            break
          else:
            current=current.right

  def search(self,val):
    current = self.root
    while current:
      if val==current.val:
        return True
      elif val<current.val:
        current=current.left
      else:
        current=current.right
    return False

tree = BinaryTree()
tree.insert(5)
tree.insert(3)
tree.insert(7)

print(tree.search(75))

# Binary Search
def binary_search(arr,x):
  low = 0
  high = len(arr)-1
  mid = 0

  while low<=high:
    mid = (high+low)//2
    if arr[mid]<x:
      low=mid+1
    elif arr[mid]>x:
      high=mid-1
    else:
      return mid
  return -1

arr = [ 2, 3, 4, 10, 40,67,10,92 ]
x = 67
print(binary_search(arr,x))

# Linear Search

lst = [64, 25, 12, 22, 11]
for i in range(len(lst)):
  for j in range(len(lst)-1):
    if lst[j]>lst[j+1]:
      lst[j],lst[j+1]=lst[j+1],lst[j]

print(lst)

# Selection Sort
def selection_sort(lst):
  for i in range(len(lst)):
    min_val_index = i
    for j in range(i+1,len(lst)):
      if lst[j]<lst[min_val_index]:
        min_val_index=j
    lst[i],lst[min_val_index]=lst[min_val_index],lst[i]
  return lst

lst = [54,23,99,6,1,67,8]
selection_sort(lst)

# Insertion Sort
def insertion_sort(lst):
  for i in range(1,len(lst)):
    curr=lst[i]
    j=i-1
    while j>=0 and lst[j]>curr:
      lst[j+1]=lst[j]
      j-=1
    lst[j+1]=curr
  return lst

lst = [54,23,99,6,1,67,8]
insertion_sort(lst)

# Quick Sort
def quicksort(lst):
  if len(lst)<2:
    return lst

  pivot = lst[-1]
  smaller = []
  larger=[]

  for i in lst[:-1]:
    if i<pivot:
      smaller.append(i)
    else:
      larger.append(i)
  return quicksort(smaller)+[pivot]+quicksort(larger)

lst = [54,23,99,6,1,67,8]
quicksort(lst)

# Merge Sort

def merge_sort(lst):
  if len(lst)<=1:
    return lst

  mid = len(lst)//2
  left_half=lst[:mid]
  right_half=lst[mid:]

  left_half = merge_sort(left_half)
  right_half=merge_sort(right_half)

  return merge(left_half,right_half)

lst = [54,23,99,6,1,67,8]
merge_sort(lst)

def merge(left_half,right_half):
  merged=[]
  left_index=0
  right_index=0

  while left_index<len(left_half) and right_index<len(right_half):
    if left_half[left_index]<right_half[right_index]:
      merged.append(left_half[left_index])
      left_index+=1
    else:
      merged.append(right_half[right_index])
      right_index+=1

  while left_index<len(left_half):
    merged.append(left_half[left_index])
    left_index+=1

  while right_index<len(right_half):
    merged.append(right_half[right_index])
    right_index+=1
  return merged

# Stack
class Stack:
  def __init__(self):
    self.stack=[]

  def push(self,item):
    self.stack.append(item)

  def pop(self):
    if len(self.stack)==0:
      return None
    return self.stack.pop()

  def peek(self):
    if len(self.stack)==0:
      return None
    return self.stack[-1]

my_stack=Stack()
my_stack.push(5)
my_stack.push(10)
my_stack.push(15)

print(my_stack.peek())
my_stack.pop()
print('After pop:',my_stack.peek())

# Queue
class Queue:
  def __init__(self):
    self.items=[]

  def enqueue(self,item):
    self.items.append(item)

  def dequeue(self):
    if len(self.items)==0:
      print('list is empty')
      return
    self.items.pop(0)

  def peek(self):
    if len(self.items)==0:
      print('list is empty')
      return
    return self.items[0]

q = Queue()
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)

print('peek:',q.peek())
q.dequeue()
print('after depeek:',q.peek())

"""# Design Pattern"""

# Singleton Classes

class Singleton:
  _instance = None

  def __new__(cls,*args,**kwargs):
    if cls._instance is None:
      cls._instance = super().__new__(cls,*args,**kwargs)
    return cls._instance

s1 = Singleton()
s1.data=10
print('s1 data:',s1.data)

s2 = Singleton()
print('s2 data:',s2.data)

s2.data=15
print('s1 data:',s1.data)

# Factory Pattern

from abc import ABCMeta, abstractmethod

class Person(metaclass=ABCMeta):
  @abstractmethod
  def create(self):
    pass

class HR(Person):
  def create(self,name):
    print(f'HR {name} is created')

class Engineer(Person):
  def create(self,name):
    print(f'Engineer {name} is created')

class PersonFactory:
  @classmethod
  def createPerson(cls,designation,name):
    eval(designation)().create(name)

if __name__=='__main__':
  designation='Engineer'
  name = 'Krishna'
  PersonFactory.createPerson(designation,name)

# Template design pattern

class Cook:
  def prepareDish(self):
    self.cutter = Cutter()
    self.cutter.cutVegetable()

    self.boiler = Boiler()
    self.boiler.boilVegetables()

    self.frier = Frier()
    self.frier.fryVegetables()

class Cutter:
  def cutVegetable(self):
    print('All vegies are cut')

class Boiler:
  def boilVegetables(self):
    print('All vegies are boiled')

class Frier:
  def fryVegetables(self):
    print('All vegies are fried')


if __name__=='__main__':
  cook = Cook()
  cook.prepareDish()

from abc import ABCMeta, abstractmethod

class ThreeDaysTrip(metaclass=ABCMeta):
  @abstractmethod
  def transport(self):
    pass

  @abstractmethod
  def day1(self):
    pass

  @abstractmethod
  def day2(self):
    pass

  @abstractmethod
  def day3(self):
    pass

  @abstractmethod
  def backtohome(self):
    pass

  def iternary(self):
    print('trip is started')
    self.transport()
    self.day1()
    self.day2()
    self.day3()
    self.backtohome()
    print('Trip is over')

class KeralaTrip(ThreeDaysTrip):
  def transport(self):
    print('will go to Kerala by train')

  def day1(self):
    print('go to boat')

  def day2(self):
    print('go to beach')

  def day3(self):
    print('to for shopping')

  def backtohome(self):
    print('will go back by plan')

k = KeralaTrip()
k.iternary()

# command design pattern

from abc import ABC, abstractmethod

class BaseCommand(ABC):
  @abstractmethod
  def execute(self):
    pass

class EmailCommand(BaseCommand):
  def __init__(self,receiver,data):
    self.receiver=receiver
    self.data=data

  def execute(self):
    self.receiver.send_email(self.data)

class SMSCommand(BaseCommand):
  def __init__(self,receiver,data):
    self.receiver=receiver
    self.data=data

  def execute(self):
    self.receiver.send_sms(self.data)


class NotificationService:
  def send_email(self,data):
    print('sending email:',data)

  def send_sms(self,data):
    print('sending sms:',data)

class NotificationInvoker:
  def __init__(self):
    self.notification_history=[]

  def invoke(self,command):
    self.notification_history.append(command)
    command.execute()

invoker = NotificationInvoker()
receiver = NotificationService()

invoker.invoke(EmailCommand(receiver,{'sub':'Test email'}))
invoker.invoke(SMSCommand(receiver,{'sub':'Test SMS'}))

# Observer Design Pattern
class Subject:
  def __init__(self):
    self.observers=[]

  def register_observer(self,observer):
    self.observers.append(observer)

  def remove_observer(self,observer):
    self.observers.remove(observer)

  def notify_observers(self,message):
    for observer in self.observers:
      observer.update(message)

class Observer:
  def __init__(self,name):
    self.name=name

  def update(self,message):
    print(f'{message} received message')

subject = Subject()
o1 = Observer('Observer 1')
o2 = Observer('Observer 2')
o3 = Observer('Observer 3')

subject.register_observer(o1)
subject.register_observer(o2)
subject.register_observer(o3)

subject.notify_observers('Hello Team')
subject.remove_observer(o2)
subject.notify_observers('Hello Again')

# Command design pattern

from abc import ABCMeta, abstractmethod

class AbstractCmd(metaclass=ABCMeta):
  @abstractmethod
  def execute(self,command):
    pass

class RealCmd(AbstractCmd):
  def execute(self,command):
    print(f'{command} command executed')

class ProxyCmd(AbstractCmd):
  def __init__(self,user):
    self.is_authorised=False
    if user=='admin':
      self.is_authorised=True
    self.executor=RealCmd()
    self.restricted_commands = ['rm','mv']

  def execute(self,command):
    if self.is_authorised:
      self.executor.execute(command)
    else:
      if any([command.strip().startswith(cmd) for cmd in self.restricted_commands]):
        print(f'{command} is not allowed for non-admin users')
      else:
        self.executor.execute(command)

admin_executor = ProxyCmd('admin')
admin_executor.execute('ls -la')
admin_executor.execute('rm -rf/')

other_executor=ProxyCmd('other')
other_executor.execute('ls -la')
other_executor.execute('rm -rf/')

# TheadPoolExecutor

import concurrent.futures

def task(name):
  import time
  print(f'Task{name} is started')
  time.sleep(2)
  print(f'Task {name} is completed')
  return f'Result from Task {name}'

with concurrent.futures.ThreadPoolExecutor() as executor:
  results = executor.map(task,range(1,6))

print('All tasks completed:')

for result in results:
  print(result)

# ProcessPoolExecutor

import concurrent.futures

def task(name):
  import time
  print(f'task {name} is started')
  time.sleep(2)
  print(f'task {name} is completed')
  return f'Result from task {name}'

with concurrent.futures.ProcessPoolExecutor() as executor:
  results = executor.map(task, range(1,6))

print('All tasks completed')

for result in results:
  print(result)

# Multiprocessing Process

import multiprocessing

def worker_function(x):
  print(f'Worker {x} started')
  result = x*x
  print(f'Worker {x} is completed')
  return result

if __name__=='__main__':
  processes = []
  for i in range(4):
    process = multiprocessing.Process(target=worker_function, args=(i,))
    processes.append(process)
    process.start()

  for process in processes:
    process.join()

# Multiprocessing Pool

import multiprocessing

def worker_function(x):
  return x*x

if __name__=='__main__':
  with multiprocessing.Pool(processes=4) as pool:
    result = pool.map(worker_function, range(10))
    print(result)

# Multiprocessing Queue

import multiprocessing

def producer(queue):
  for i in range(5):
    queue.put(i)
    print(f'Produced: {i}')

def consumer(queue):
  while True:
    item = queue.get()
    if item is None:
      break
    print(f'Consumed {item}')

if __name__ =='__main__':
  queue = multiprocessing.Queue()
  producer_process = multiprocessing.Process(target=producer, args=(queue,))
  consumer_process = multiprocessing.Process(target=consumer, args=(queue,))

  producer_process.start()
  consumer_process.start()

  producer_process.join()
  queue.put(None)

  consumer_process.join()

  print('Both producer and consumer process is completed')

# Multithreading

import threading

def worker_function():
  for i in range(5):
    print(f'Thread {threading.current_thread().name}: {i}')

thread1 = threading.Thread(target=worker_function)
thread2 = threading.Thread(target=worker_function)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

print('Both threads have finished')
